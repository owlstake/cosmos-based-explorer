{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.repeat.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.find.js\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { BSkeleton, BSkeletonWrapper, BRow, BCol, VBTooltip, BFormInput, BCard, BAlert, BFormCheckbox, BButton, BBadge, BInputGroup, BInputGroupPrepend } from 'bootstrap-vue';\nimport { consensusPubkeyToHexAddress, getCachedValidators, timeIn, toDay } from '@/libs/utils';\nimport { Bech32, toHex } from '@cosmjs/encoding';\nexport default {\n  components: {\n    BRow: BRow,\n    BCol: BCol,\n    BFormInput: BFormInput,\n    BCard: BCard,\n    BAlert: BAlert,\n    BButton: BButton,\n    BBadge: BBadge,\n    BFormCheckbox: BFormCheckbox,\n    BInputGroup: BInputGroup,\n    BSkeleton: BSkeleton,\n    BSkeletonWrapper: BSkeletonWrapper,\n    BInputGroupPrepend: BInputGroupPrepend\n  },\n  directives: {\n    'b-tooltip': VBTooltip\n  },\n  data: function data() {\n    var chain = this.$route.params.chain;\n    var pinned = localStorage.getItem('pinned') ? localStorage.getItem('pinned').split(',') : '';\n    return {\n      loading: true,\n      missedFilter: false,\n      pinned: pinned,\n      chain: chain,\n      query: '',\n      validators: [],\n      missing: {},\n      blocks: Array.from('0'.repeat(50)).map(function (x) {\n        return {\n          sigs: {},\n          height: Number(x)\n        };\n      }),\n      syncing: false,\n      latestTime: ''\n    };\n  },\n  computed: {\n    uptime: function uptime() {\n      var _this = this;\n\n      var vals = this.query ? this.validators.filter(function (x) {\n        return String(x.description.moniker).indexOf(_this.query) > -1;\n      }) : this.validators;\n      vals.sort(function (a, b) {\n        return b.delegator_shares - a.delegator_shares;\n      });\n      var rets = vals.map(function (x) {\n        return {\n          validator: x.description,\n          address: consensusPubkeyToHexAddress(x.consensus_pubkey)\n        };\n      });\n\n      if (this.missedFilter) {\n        return rets.filter(function (x) {\n          return _this.missing[x.address].missed_blocks_counter > 0;\n        });\n      }\n\n      return rets;\n    }\n  },\n  created: function created() {\n    var _this2 = this;\n\n    var cached = JSON.parse(getCachedValidators(this.$route.params.chain));\n\n    if (cached) {\n      this.validators = cached;\n    }\n\n    this.$http.getValidatorList().then(function (res) {\n      _this2.validators = res;\n    });\n    this.$http.getSlashingSigningInfo().then(function (res) {\n      if (res.info) {\n        res.info.forEach(function (x) {\n          if (x.address) {\n            var hex = toHex(Bech32.decode(x.address).data).toUpperCase();\n            _this2.missing[hex] = x;\n          }\n        });\n      }\n    });\n    this.initBlocks();\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.blocks = []; // clear running tasks if it is not finish\n\n    this.syncing = false;\n    clearInterval(this.timer);\n  },\n  methods: {\n    pinValidator: function pinValidator() {\n      localStorage.setItem('pinned', this.pinned);\n    },\n    initBlocks: function initBlocks() {\n      var _this3 = this;\n\n      this.$http.getLatestBlock().then(function (d) {\n        var height = d.block.last_commit.height;\n\n        if (timeIn(d.block.header.time, 3, 'm')) {\n          _this3.syncing = true;\n        } else {\n          _this3.syncing = false;\n        }\n\n        _this3.latestTime = toDay(d.block.header.time, 'long');\n        var blocks = []; // update height\n\n        var promise = Promise.resolve();\n\n        var _loop = function _loop(i) {\n          blocks.unshift({\n            sigs: {},\n            height: i > 0 ? i : 0\n          });\n\n          if (i > height - 48 && i > 0) {\n            promise = promise.then(function () {\n              return new Promise(function (resolve) {\n                _this3.fetch_status(i, resolve);\n              });\n            });\n          }\n        };\n\n        for (var i = height - 1; i > height - 50; i -= 1) {\n          _loop(i);\n        }\n\n        var sigs = _this3.initColor();\n\n        d.block.last_commit.signatures.forEach(function (x) {\n          if (x.validator_address) sigs[x.validator_address] = 'bg-success';\n        });\n        blocks.push({\n          sigs: sigs,\n          height: height\n        });\n        _this3.blocks = blocks;\n        _this3.timer = setInterval(_this3.fetch_latest, 6000);\n        _this3.loading = false;\n      });\n    },\n    initColor: function initColor() {\n      var sigs = {};\n      this.validators.forEach(function (x) {\n        sigs[consensusPubkeyToHexAddress(x.consensus_pubkey)] = 'bg-danger';\n      });\n      return sigs;\n    },\n    fetch_status: function fetch_status(height, resolve) {\n      var _this4 = this;\n\n      var block = this.blocks.find(function (b) {\n        return b.height === height;\n      });\n\n      if (block) {\n        this.$http.getBlockByHeight(height).then(function (res) {\n          resolve();\n\n          var sigs = _this4.initColor();\n\n          res.block.last_commit.signatures.forEach(function (x) {\n            if (x.validator_address) sigs[x.validator_address] = 'bg-success';\n          });\n\n          _this4.$set(block, 'sigs', sigs);\n        });\n      }\n    },\n    fetch_latest: function fetch_latest() {\n      var _this5 = this;\n\n      this.$http.getLatestBlock().then(function (res) {\n        var sigs = _this5.initColor();\n\n        res.block.last_commit.signatures.forEach(function (x) {\n          if (x.validator_address) sigs[x.validator_address] = 'bg-success';\n        });\n\n        var block = _this5.blocks.find(function (b) {\n          return b.height === res.block.last_commit.height;\n        });\n\n        if (typeof block === 'undefined') {\n          // mei\n          // this.$set(block, 0, typeof sigs !== 'undefined')\n          if (_this5.blocks.length >= 50) _this5.blocks.shift();\n\n          _this5.blocks.push({\n            sigs: sigs,\n            height: res.block.last_commit.height\n          });\n        }\n      });\n    }\n  }\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsGA,SACAA,SADA,EACAC,gBADA,EAEAC,IAFA,EAEAC,IAFA,EAEAC,SAFA,EAEAC,UAFA,EAEAC,KAFA,EAEAC,MAFA,EAEAC,aAFA,EAEAC,OAFA,EAEAC,MAFA,EAEAC,WAFA,EAEAC,kBAFA,QAGA,eAHA;AAKA,SACAC,2BADA,EACAC,mBADA,EACAC,MADA,EACAC,KADA,QAEA,cAFA;AAGA;AAEA;EACAC;IACAf,UADA;IAEAC,UAFA;IAGAE,sBAHA;IAIAC,YAJA;IAKAC,cALA;IAMAE,gBANA;IAOAC,cAPA;IAQAF,4BARA;IASAG,wBATA;IAUAX,oBAVA;IAWAC,kCAXA;IAYAW;EAZA,CADA;EAeAM;IACA;EADA,CAfA;EAkBAC,IAlBA,kBAkBA;IACA;IACA;IACA;MACAC,aADA;MAEAC,mBAFA;MAGAC,cAHA;MAIAC,YAJA;MAKAC,SALA;MAMAC,cANA;MAOAC,WAPA;MAQAC;QAAA;UAAAC;UAAAC;QAAA;MAAA,EARA;MASAC,cATA;MAUAC;IAVA;EAYA,CAjCA;EAkCAC;IACAC,MADA,oBACA;MAAA;;MACA;QAAA;MAAA;MACAC;QAAA;MAAA;MACA;QAAA;UACAC,wBADA;UAEAC;QAFA;MAAA;;MAIA;QACA;UAAA;QAAA;MACA;;MACA;IACA;EAZA,CAlCA;EAgDAC,OAhDA,qBAgDA;IAAA;;IACA;;IAEA;MACA;IACA;;IACA;MACA;IACA,CAFA;IAGA;MACA;QACAC;UACA;YACA;YACA;UACA;QACA,CALA;MAMA;IACA,CATA;IAUA;EACA,CApEA;EAqEAC,aArEA,2BAqEA;IACA,iBADA,CACA;;IACA;IACAC;EACA,CAzEA;EA0EAC;IACAC,YADA,0BACA;MACAC;IACA,CAHA;IAIAC,UAJA,wBAIA;MAAA;;MACA;QACA;;QACA;UACA;QACA,CAFA,MAEA;UACA;QACA;;QACA;QACA,gBARA,CASA;;QACA;;QAVA,2BAWAC,CAXA;UAYAlB;YAAAC;YAAAC;UAAA;;UACA;YACAiB;cAAA;gBACA;cACA,CAFA;YAAA;UAGA;QAjBA;;QAWA;UAAA;QAOA;;QAEA;;QACAC;UACA;QACA,CAFA;QAGApB;UAAAC;UAAAC;QAAA;QACA;QAEA;QACA;MACA,CA7BA;IA8BA,CAnCA;IAoCAmB,SApCA,uBAoCA;MACA;MACA;QACApB;MACA,CAFA;MAGA;IACA,CA1CA;IA2CAqB,YA3CA,wBA2CApB,MA3CA,EA2CAqB,OA3CA,EA2CA;MAAA;;MACA;QAAA;MAAA;;MACA;QACA;UACAA;;UACA;;UACAZ;YACA;UACA,CAFA;;UAGA;QACA,CAPA;MAQA;IACA,CAvDA;IAwDAa,YAxDA,0BAwDA;MAAA;;MACA;QACA;;QACAb;UACA;QACA,CAFA;;QAGA;UAAA;QAAA;;QACA;UAAA;UACA;UACA;;UACA;YAAAV;YAAAC;UAAA;QACA;MACA,CAXA;IAYA;EArEA;AA1EA","names":["BSkeleton","BSkeletonWrapper","BRow","BCol","VBTooltip","BFormInput","BCard","BAlert","BFormCheckbox","BButton","BBadge","BInputGroup","BInputGroupPrepend","consensusPubkeyToHexAddress","getCachedValidators","timeIn","toDay","components","directives","data","loading","missedFilter","pinned","chain","query","validators","missing","blocks","sigs","height","syncing","latestTime","computed","uptime","vals","validator","address","created","res","beforeDestroy","clearInterval","methods","pinValidator","localStorage","initBlocks","i","promise","d","initColor","fetch_status","resolve","fetch_latest"],"sourceRoot":"src/views","sources":["Uptime.vue"],"sourcesContent":["<template>\n  <div class=\"px-0\">\n    <b-card>\n      <b-alert\n        variant=\"danger\"\n        :show=\"syncing\"\n      >\n        <div class=\"alert-body\">\n          <span>No new blocks have been produced since  <strong>{{ latestTime }}</strong> </span>\n        </div>\n      </b-alert>\n      <b-card\n        no-body\n        class=\"mb-1\"\n      >\n        <b-button\n          to=\"./uptime/my\"\n          variant=\"primary\"\n        >\n          Browse favorite only\n        </b-button>\n        <b-input-group>\n          <b-input-group-prepend is-text>\n            <b-form-checkbox\n              v-model=\"missedFilter\"\n              v-b-tooltip.hover\n              title=\"Only missed blocks\"\n              name=\"viewMissed\"\n            />\n          </b-input-group-prepend>\n          <b-form-input\n            v-model=\"query\"\n            placeholder=\"Keywords to filter validators\"\n          />\n        </b-input-group>\n      </b-card>\n      <b-row>\n        <b-col\n          v-for=\"(x,index) in uptime\"\n          :key=\"index\"\n          sm=\"12\"\n          md=\"4\"\n          xl=\"3\"\n          class=\"text-truncate\"\n        >\n          <div class=\"d-flex justify-content-between\">\n            <b-form-checkbox\n              v-model=\"pinned\"\n              :value=\"`${chain}#${x.address}`\"\n              class=\"custom-control-warning text-truncate\"\n              @change=\"pinValidator(`${chain}#${x.address}`)\"\n            ><span class=\"d-inline-block text-truncate font-weight-bold align-bottom\">{{ index+1 }} {{ x.validator.moniker }}</span>\n            </b-form-checkbox>\n            <span v-if=\"missing[x.address]\">\n              <b-badge\n                v-if=\"missing[x.address].missed_blocks_counter > 0\"\n                v-b-tooltip.hover.v-danger\n                variant=\"light-danger\"\n                :title=\"`${missing[x.address].missed_blocks_counter} missed blocks`\"\n                class=\"text-danger text-bolder\"\n              >\n                {{ missing[x.address].missed_blocks_counter }}\n              </b-badge>\n              <b-badge\n                v-else\n                v-b-tooltip.hover.v-success\n                variant=\"light-success\"\n                title=\"Perfect! No missed blocks\"\n              >\n                0\n              </b-badge>\n            </span>\n          </div>\n          <b-skeleton-wrapper :loading=\"loading\">\n            <template #loading>\n              <b-skeleton width=\"100%\" />\n            </template>\n            <template #default>\n              <div class=\"d-flex justify-content-between align-self-stretch flex-wrap\">\n                <div\n                  v-for=\"(b,i) in blocks\"\n                  :key=\"i\"\n                  style=\"width:1.5%;\"\n                ><router-link :to=\"`./blocks/${b.height}`\">\n                  <div\n                    v-b-tooltip.hover.v-second\n                    :title=\"b.height\"\n                    :class=\"b.sigs && b.sigs[x.address] ? b.sigs[x.address] : 'bg-light-success'\"\n                    class=\"m-auto\"\n                  >&nbsp;</div>\n                </router-link>\n                </div>\n              </div>\n            </template>\n          </b-skeleton-wrapper>\n        </b-col>\n      </b-row>\n    </b-card>\n  </div>\n</template>\n\n<script>\nimport {\n  BSkeleton, BSkeletonWrapper,\n  BRow, BCol, VBTooltip, BFormInput, BCard, BAlert, BFormCheckbox, BButton, BBadge, BInputGroup, BInputGroupPrepend,\n} from 'bootstrap-vue'\n\nimport {\n  consensusPubkeyToHexAddress, getCachedValidators, timeIn, toDay,\n} from '@/libs/utils'\nimport { Bech32, toHex } from '@cosmjs/encoding'\n\nexport default {\n  components: {\n    BRow,\n    BCol,\n    BFormInput,\n    BCard,\n    BAlert,\n    BButton,\n    BBadge,\n    BFormCheckbox,\n    BInputGroup,\n    BSkeleton,\n    BSkeletonWrapper,\n    BInputGroupPrepend,\n  },\n  directives: {\n    'b-tooltip': VBTooltip,\n  },\n  data() {\n    const { chain } = this.$route.params\n    const pinned = localStorage.getItem('pinned') ? localStorage.getItem('pinned').split(',') : ''\n    return {\n      loading: true,\n      missedFilter: false,\n      pinned,\n      chain,\n      query: '',\n      validators: [],\n      missing: {},\n      blocks: Array.from('0'.repeat(50)).map(x => ({ sigs: {}, height: Number(x) })),\n      syncing: false,\n      latestTime: '',\n    }\n  },\n  computed: {\n    uptime() {\n      const vals = this.query ? this.validators.filter(x => String(x.description.moniker).indexOf(this.query) > -1) : this.validators\n      vals.sort((a, b) => b.delegator_shares - a.delegator_shares)\n      const rets = vals.map(x => ({\n        validator: x.description,\n        address: consensusPubkeyToHexAddress(x.consensus_pubkey),\n      }))\n      if (this.missedFilter) {\n        return rets.filter(x => this.missing[x.address].missed_blocks_counter > 0)\n      }\n      return rets\n    },\n  },\n  created() {\n    const cached = JSON.parse(getCachedValidators(this.$route.params.chain))\n\n    if (cached) {\n      this.validators = cached\n    }\n    this.$http.getValidatorList().then(res => {\n      this.validators = res\n    })\n    this.$http.getSlashingSigningInfo().then(res => {\n      if (res.info) {\n        res.info.forEach(x => {\n          if (x.address) {\n            const hex = toHex(Bech32.decode(x.address).data).toUpperCase()\n            this.missing[hex] = x\n          }\n        })\n      }\n    })\n    this.initBlocks()\n  },\n  beforeDestroy() {\n    this.blocks = [] // clear running tasks if it is not finish\n    this.syncing = false\n    clearInterval(this.timer)\n  },\n  methods: {\n    pinValidator() {\n      localStorage.setItem('pinned', this.pinned)\n    },\n    initBlocks() {\n      this.$http.getLatestBlock().then(d => {\n        const { height } = d.block.last_commit\n        if (timeIn(d.block.header.time, 3, 'm')) {\n          this.syncing = true\n        } else {\n          this.syncing = false\n        }\n        this.latestTime = toDay(d.block.header.time, 'long')\n        const blocks = []\n        // update height\n        let promise = Promise.resolve()\n        for (let i = height - 1; i > height - 50; i -= 1) {\n          blocks.unshift({ sigs: {}, height: i > 0 ? i : 0 })\n          if (i > height - 48 && i > 0) {\n            promise = promise.then(() => new Promise(resolve => {\n              this.fetch_status(i, resolve)\n            }))\n          }\n        }\n\n        const sigs = this.initColor()\n        d.block.last_commit.signatures.forEach(x => {\n          if (x.validator_address) sigs[x.validator_address] = 'bg-success'\n        })\n        blocks.push({ sigs, height })\n        this.blocks = blocks\n\n        this.timer = setInterval(this.fetch_latest, 6000)\n        this.loading = false\n      })\n    },\n    initColor() {\n      const sigs = {}\n      this.validators.forEach(x => {\n        sigs[consensusPubkeyToHexAddress(x.consensus_pubkey)] = 'bg-danger'\n      })\n      return sigs\n    },\n    fetch_status(height, resolve) {\n      const block = this.blocks.find(b => b.height === height)\n      if (block) {\n        this.$http.getBlockByHeight(height).then(res => {\n          resolve()\n          const sigs = this.initColor()\n          res.block.last_commit.signatures.forEach(x => {\n            if (x.validator_address) sigs[x.validator_address] = 'bg-success'\n          })\n          this.$set(block, 'sigs', sigs)\n        })\n      }\n    },\n    fetch_latest() {\n      this.$http.getLatestBlock().then(res => {\n        const sigs = this.initColor()\n        res.block.last_commit.signatures.forEach(x => {\n          if (x.validator_address) sigs[x.validator_address] = 'bg-success'\n        })\n        const block = this.blocks.find(b => b.height === res.block.last_commit.height)\n        if (typeof block === 'undefined') { // mei\n          // this.$set(block, 0, typeof sigs !== 'undefined')\n          if (this.blocks.length >= 50) this.blocks.shift()\n          this.blocks.push({ sigs, height: res.block.last_commit.height })\n        }\n      })\n    },\n  },\n}\n</script>\n\n<style></style>\n"]},"metadata":{},"sourceType":"module"}