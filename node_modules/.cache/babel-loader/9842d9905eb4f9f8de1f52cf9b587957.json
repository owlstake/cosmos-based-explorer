{"ast":null,"code":"//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { BAvatar, BCardFooter, BRow, BCol, BBreadcrumb, BCard, BCardBody, BInputGroup, BFormInput, BInputGroupAppend, BButton } from 'bootstrap-vue';\nimport fetch from 'node-fetch';\nimport { consensusPubkeyToHexAddress, getLocalChains } from '@/libs/utils';\nimport vSelect from 'vue-select';\nimport AppFooter from '@/@core/layouts/components/AppFooter.vue';\nimport FullHeader from './components/FullHeader.vue';\nexport default {\n  components: {\n    FullHeader,\n    BBreadcrumb,\n    BRow,\n    BCol,\n    BCard,\n    BCardBody,\n    BCardFooter,\n    BInputGroup,\n    BFormInput,\n    BInputGroupAppend,\n    BButton,\n    BAvatar,\n    vSelect,\n    AppFooter\n  },\n\n  data() {\n    const chains = getLocalChains();\n    const selected = 'agoric';\n    return {\n      navs: [{\n        text: 'Tools'\n      }, {\n        text: 'Consensus Monitor'\n      }],\n      showPrevote: false,\n      rpc: `${chains[selected].rpc[0]}/consensus_state`,\n      httpstatus: 200,\n      httpStatusText: '',\n      roundState: {},\n      selected,\n      chains,\n      vals: [],\n      positions: []\n    };\n  },\n\n  created() {\n    this.validators();\n  },\n\n  methods: {\n    color(i, txt) {\n      if (i === this.roundState.proposer.index) {\n        return txt === 'nil-Vote' ? 'outline-primary' : 'primary';\n      }\n\n      return txt === 'nil-Vote' ? 'outline-secondary' : 'success';\n    },\n\n    update() {\n      fetch(this.rpc).then(data => {\n        this.httpstatus = data.status;\n        this.httpStatusText = data.httpStatusText;\n        return data.json();\n      }).then(res => {\n        this.roundState = res.result.round_state;\n      }).catch(err => {\n        this.httpstatus = 500;\n        this.httpStatusText = err;\n      });\n    },\n\n    validators() {\n      const conf = this.chains[this.selected];\n      this.$http.getValidatorList(conf).then(data => {\n        this.vals = data.map(x => {\n          const x2 = x;\n          x2.hex = consensusPubkeyToHexAddress(x.consensus_pubkey);\n          return x2;\n        });\n      });\n    },\n\n    onchange(v) {\n      this.httpstatus = 200;\n      this.httpStatusText = '';\n      this.roundState = {};\n      this.selected = v.chain_name;\n      this.rpc = `${v.rpc[0]}/consensus_state`; // used for mapping nil-vote validators\n\n      fetch(`${v.rpc[0]}/validators?per_page=100`).then(data => data.json()).then(res2 => {\n        this.positions = res2.result.validators;\n\n        if (res2.result.total > 100) {\n          fetch(`${v.rpc[0]}/validators?page=2&per_page=100`).then(data => data.json()).then(res => {\n            this.positions = this.positions.concat(res.result.validators);\n          });\n        }\n      }).catch(err => {\n        this.httpstatus = 500;\n        this.httpStatusText = err;\n      });\n      this.validators();\n    },\n\n    showName(i, text) {\n      if (text === 'nil-Vote') {\n        if (this.positions[i]) {\n          const val = this.vals.find(x => x.hex === this.positions[i].address);\n          return val?.description?.moniker || i;\n        }\n\n        return i;\n      }\n\n      const txt = text.substring(text.indexOf(':') + 1, text.indexOf(' '));\n      const val = this.vals.find(x => x.hex.startsWith(txt));\n      return val?.description?.moniker || txt;\n    }\n\n  }\n};","map":null,"metadata":{},"sourceType":"module"}