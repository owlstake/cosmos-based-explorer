{"ast":null,"code":"//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { BSkeleton, BSkeletonWrapper, BRow, BCol, VBTooltip, BFormInput, BCard, BAlert, BFormCheckbox, BButton, BBadge, BInputGroup, BInputGroupPrepend } from 'bootstrap-vue';\nimport { consensusPubkeyToHexAddress, getCachedValidators, timeIn, toDay } from '@/libs/utils';\nimport { Bech32, toHex } from '@cosmjs/encoding';\nexport default {\n  components: {\n    BRow,\n    BCol,\n    BFormInput,\n    BCard,\n    BAlert,\n    BButton,\n    BBadge,\n    BFormCheckbox,\n    BInputGroup,\n    BSkeleton,\n    BSkeletonWrapper,\n    BInputGroupPrepend\n  },\n  directives: {\n    'b-tooltip': VBTooltip\n  },\n\n  data() {\n    const {\n      chain\n    } = this.$route.params;\n    const pinned = localStorage.getItem('pinned') ? localStorage.getItem('pinned').split(',') : '';\n    return {\n      loading: true,\n      missedFilter: false,\n      pinned,\n      chain,\n      query: '',\n      validators: [],\n      missing: {},\n      blocks: Array.from('0'.repeat(50)).map(x => ({\n        sigs: {},\n        height: Number(x)\n      })),\n      syncing: false,\n      latestTime: ''\n    };\n  },\n\n  computed: {\n    uptime() {\n      const vals = this.query ? this.validators.filter(x => String(x.description.moniker).indexOf(this.query) > -1) : this.validators;\n      vals.sort((a, b) => b.delegator_shares - a.delegator_shares);\n      const rets = vals.map(x => ({\n        validator: x.description,\n        address: consensusPubkeyToHexAddress(x.consensus_pubkey)\n      }));\n\n      if (this.missedFilter) {\n        return rets.filter(x => this.missing[x.address].missed_blocks_counter > 0);\n      }\n\n      return rets;\n    }\n\n  },\n\n  created() {\n    const cached = JSON.parse(getCachedValidators(this.$route.params.chain));\n\n    if (cached) {\n      this.validators = cached;\n    }\n\n    this.$http.getValidatorList().then(res => {\n      this.validators = res;\n    });\n    this.$http.getSlashingSigningInfo().then(res => {\n      if (res.info) {\n        res.info.forEach(x => {\n          if (x.address) {\n            const hex = toHex(Bech32.decode(x.address).data).toUpperCase();\n            this.missing[hex] = x;\n          }\n        });\n      }\n    });\n    this.initBlocks();\n  },\n\n  beforeDestroy() {\n    this.blocks = []; // clear running tasks if it is not finish\n\n    this.syncing = false;\n    clearInterval(this.timer);\n  },\n\n  methods: {\n    pinValidator() {\n      localStorage.setItem('pinned', this.pinned);\n    },\n\n    initBlocks() {\n      this.$http.getLatestBlock().then(d => {\n        const {\n          height\n        } = d.block.last_commit;\n\n        if (timeIn(d.block.header.time, 3, 'm')) {\n          this.syncing = true;\n        } else {\n          this.syncing = false;\n        }\n\n        this.latestTime = toDay(d.block.header.time, 'long');\n        const blocks = []; // update height\n\n        let promise = Promise.resolve();\n\n        for (let i = height - 1; i > height - 50; i -= 1) {\n          blocks.unshift({\n            sigs: {},\n            height: i > 0 ? i : 0\n          });\n\n          if (i > height - 48 && i > 0) {\n            promise = promise.then(() => new Promise(resolve => {\n              this.fetch_status(i, resolve);\n            }));\n          }\n        }\n\n        const sigs = this.initColor();\n        d.block.last_commit.signatures.forEach(x => {\n          if (x.validator_address) sigs[x.validator_address] = 'bg-success';\n        });\n        blocks.push({\n          sigs,\n          height\n        });\n        this.blocks = blocks;\n        this.timer = setInterval(this.fetch_latest, 6000);\n        this.loading = false;\n      });\n    },\n\n    initColor() {\n      const sigs = {};\n      this.validators.forEach(x => {\n        sigs[consensusPubkeyToHexAddress(x.consensus_pubkey)] = 'bg-danger';\n      });\n      return sigs;\n    },\n\n    fetch_status(height, resolve) {\n      const block = this.blocks.find(b => b.height === height);\n\n      if (block) {\n        this.$http.getBlockByHeight(height).then(res => {\n          resolve();\n          const sigs = this.initColor();\n          res.block.last_commit.signatures.forEach(x => {\n            if (x.validator_address) sigs[x.validator_address] = 'bg-success';\n          });\n          this.$set(block, 'sigs', sigs);\n        });\n      }\n    },\n\n    fetch_latest() {\n      this.$http.getLatestBlock().then(res => {\n        const sigs = this.initColor();\n        res.block.last_commit.signatures.forEach(x => {\n          if (x.validator_address) sigs[x.validator_address] = 'bg-success';\n        });\n        const block = this.blocks.find(b => b.height === res.block.last_commit.height);\n\n        if (typeof block === 'undefined') {\n          // mei\n          // this.$set(block, 0, typeof sigs !== 'undefined')\n          if (this.blocks.length >= 50) this.blocks.shift();\n          this.blocks.push({\n            sigs,\n            height: res.block.last_commit.height\n          });\n        }\n      });\n    }\n\n  }\n};","map":null,"metadata":{},"sourceType":"module"}