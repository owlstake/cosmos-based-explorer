{"ast":null,"code":"import \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.url.js\";\nimport \"core-js/modules/web.url-search-params.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/es.math.trunc.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.string.trim.js\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { BCard, BCardTitle, BFormTextarea, BBadge } from 'bootstrap-vue';\nexport default {\n  components: {\n    BBadge: BBadge,\n    BCard: BCard,\n    BCardTitle: BCardTitle,\n    BFormTextarea: BFormTextarea\n  },\n  data: function data() {\n    var _this$$store$state$ch = this.$store.state.chains.selected,\n        rpc = _this$$store$state$ch.rpc,\n        snapshot_provider = _this$$store$state$ch.snapshot_provider;\n    var servers = '';\n\n    if (rpc && Array.isArray(rpc)) {\n      var serv = rpc;\n\n      if (serv.length === 1) {\n        serv = serv.concat(serv);\n      }\n\n      servers = serv.map(function (x) {\n        var url = new URL(x);\n\n        if (url.port === '') {\n          return \"\".concat(url.protocol, \"//\").concat(url.hostname, \":\").concat(url.protocol.startsWith('https') ? '443' : '80');\n        }\n\n        return \"\".concat(url.protocol, \"//\").concat(url.hostname, \":\").concat(url.port);\n      }).join(',');\n    } // eslint-disable-next-line camelcase\n\n\n    var peers = snapshot_provider;\n    var providers = peers ? \"# Comma separated list of nodes to keep persistent connections to \\npersistent_peers = \\\"\".concat(peers, \"\\\" \") : 'OMG！ There is NO available providers, but you can try it.';\n    return {\n      version: '',\n      snapshot_provider: snapshot_provider,\n      servers: servers,\n      providers: providers,\n      height: 0,\n      hash: '',\n      error: [],\n      state: '',\n      valid: false,\n      snapshot: \"[state-sync]\\n# snapshot-interval specifies the block interval at which local state sync snapshots are\\n# taken (0 to disable). Must be a multiple of pruning-keep-every.\\nsnapshot-interval = 1000\\n\\n# snapshot-keep-recent specifies the number of recent snapshots to keep and serve (0 to keep all). Each snapshot is about 500MiB\\nsnapshot-keep-recent = 2\"\n    };\n  },\n  created: function created() {\n    var _this = this;\n\n    var interval = 1000;\n    this.$http.getLatestBlock().then(function (l) {\n      var height = l.block.header.height;\n\n      if (height > interval * 3) {\n        _this.$http.getBlockByHeight(Math.trunc((height - 3 * interval) / interval) * interval).then(function (x) {\n          _this.hash = x.block_id.hash;\n          _this.height = x.block.header.height;\n          _this.state = \"[statesync]\\nenable = true\\nrpc_servers = \\\"\".concat(_this.servers, \"\\\"\\ntrust_height = \").concat(_this.height, \"\\ntrust_hash = \\\"\").concat(_this.hash, \"\\\"\\ntrust_period = \\\"168h\\\"  # 2/3 of unbonding time\");\n\n          _this.check();\n        });\n      }\n\n      _this.$http.getNodeInfo().then(function (res) {\n        _this.version = res.application_version.version;\n      });\n    });\n  },\n  methods: {\n    check: function check() {\n      var _this2 = this;\n\n      this.valid = true;\n      this.error = [];\n      this.state.split('\\n').forEach(function (element) {\n        var v = _this2.kv(element);\n\n        if (v[0] === 'trust_height' && Number(v[1]) < 1) {\n          _this2.valid = false;\n\n          _this2.error.push('Trust Height should be set.');\n        }\n\n        if (v[0] === 'trust_hash' && v[1].length < 10) {\n          _this2.valid = false;\n\n          _this2.error.push('Trust Hash is invalid.');\n        }\n\n        if (v[0] === 'rpc_servers') {\n          if (v[1].indexOf(',') > 1) {\n            v[1].replace(/\"/g, '').split(',').forEach(function (host) {\n              var re = /^(.)+:\\d+$/g;\n\n              if (!re.test(host)) {\n                _this2.valid = false;\n\n                _this2.error.push(\"\\\"\".concat(host, \"\\\" is not a valid host. Make sure that the port is added.\"));\n              }\n            }); // valid = true\n          } else {\n            _this2.valid = false;\n\n            _this2.error.push('No RPC serser is configured.');\n          }\n        }\n      });\n      return this.valid;\n    },\n    kv: function kv(line) {\n      if (line && line.indexOf('=') > 0) {\n        var s = line.split('=');\n        return [s[0].trim(), s[1].trim()];\n      }\n\n      return [];\n    }\n  }\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+DA,SACAA,KADA,EACAC,UADA,EACAC,aADA,EACAC,MADA,QAEA,eAFA;AAIA;EACAC;IACAD,cADA;IAEAH,YAFA;IAGAC,sBAHA;IAIAC;EAJA,CADA;EAOAG,IAPA,kBAOA;IACA;IAAA;IAAA;IACA;;IACA;MACA;;MACA;QACAC;MACA;;MACAC;QACA;;QACA;UACA;QACA;;QACA;MACA,CANA,EAMAC,IANA,CAMA,GANA;IAOA,CAfA,CAgBA;;;IACA;IACA,2HACAC,KADA,WAEA,2DAFA;IAGA;MACAC,WADA;MAEAC,oCAFA;MAGAJ,gBAHA;MAIAK,oBAJA;MAKAC,SALA;MAMAC,QANA;MAOAC,SAPA;MAQAC,SARA;MASAC,YATA;MAUAC;IAVA;EAkBA,CA9CA;EA+CAC,OA/CA,qBA+CA;IAAA;;IACA;IACA;MACA;;MACA;QACA;UACA;UACA;UACA,oEAEA,aAFA,gCAGA,YAHA,8BAIA,UAJA;;UAMA;QACA,CAVA;MAWA;;MACA;QACA;MACA,CAFA;IAGA,CAlBA;EAmBA,CApEA;EAqEAC;IACAC,KADA,mBACA;MAAA;;MACA;MACA;MACA;QACA;;QACA;UACA;;UACA;QACA;;QACA;UACA;;UACA;QACA;;QACA;UACA;YACAC;cACA;;cACA;gBACA;;gBACA;cACA;YACA,CANA,EADA,CAQA;UACA,CATA,MASA;YACA;;YACA;UACA;QACA;MACA,CAzBA;MA0BA;IACA,CA/BA;IAgCAC,EAhCA,cAgCAC,IAhCA,EAgCA;MACA;QACA;QACA;MACA;;MACA;IACA;EAtCA;AArEA","names":["BCard","BCardTitle","BFormTextarea","BBadge","components","data","serv","servers","join","peers","version","snapshot_provider","providers","height","hash","error","state","valid","snapshot","created","methods","check","v","kv","line"],"sourceRoot":"src/views","sources":["StateSync.vue"],"sourcesContent":["<template>\n  <div class=\"container-md\">\n    <b-card>\n      <b-card-title>\n        What's State Sync?\n      </b-card-title>\n      The Tendermint Core 0.34 release includes support for state sync, which allows a new node to join a network by fetching a snapshot of the application state at a recent height instead of fetching and replaying all historical blocks. This can reduce the time needed to sync with the network from days to minutes.\n      Click <a href=\"https://blog.cosmos.network/cosmos-sdk-state-sync-guide-99e4cf43be2f\">here</a> for more infomation.\n    </b-card>\n    <b-card>\n      <b-card-title>\n        Starting New Node From State Sync\n        <b-badge\n          v-if=\"snapshot_provider?false:true\"\n          variant=\"danger\"\n        >\n          WIP\n        </b-badge>\n      </b-card-title>\n      <b class=\"mt-1\">1. Install Binary ({{ version }})</b><br>\n      We need to install the binary first and make sure that the version is the one currently in use on mainnet.\n      <br><br>\n      <b class=\"mt-1\">2. Enable State Sync</b><br>\n      We can configure Tendermint to use state sync in <code>$DAEMON_HOME/config/config.toml</code>, then start daemon.\n      <ul class=\"mt-1\">\n        <li\n          v-for=\"e in error\"\n          :key=\"e\"\n          class=\"text-danger\"\n        >\n          {{ e }}\n        </li>\n      </ul>\n      <b-form-textarea\n        id=\"textarea-state\"\n        v-model=\"state\"\n        :state=\"valid\"\n        readonly\n        placeholder=\"Loading...\"\n        rows=\"7\"\n        class=\"my-1\"\n        @change=\"check()\"\n      />\n    </b-card>\n\n    <b-card>\n      <b-card-title>\n        Enable Snapshot For State Sync\n      </b-card-title>\n      To make state sync works, we can enable snapshot in <code>$DAEMON_HOME/config/app.toml</code>\n      and don't forget to share your snapshot server <a href=\"https://github.com/ping-pub/explorer/discussions\">Here</a>\n      <b-form-textarea\n        id=\"snapshot\"\n        v-model=\"snapshot\"\n        readonly\n        rows=\"8\"\n        class=\"mt-1\"\n      />\n    </b-card>\n  </div>\n</template>\n\n<script>\nimport {\n  BCard, BCardTitle, BFormTextarea, BBadge,\n} from 'bootstrap-vue'\n\nexport default {\n  components: {\n    BBadge,\n    BCard,\n    BCardTitle,\n    BFormTextarea,\n  },\n  data() {\n    const { rpc, snapshot_provider } = this.$store.state.chains.selected\n    let servers = ''\n    if (rpc && Array.isArray(rpc)) {\n      let serv = rpc\n      if (serv.length === 1) {\n        serv = serv.concat(serv)\n      }\n      servers = serv.map(x => {\n        const url = new URL(x)\n        if (url.port === '') {\n          return `${url.protocol}//${url.hostname}:${url.protocol.startsWith('https') ? '443' : '80'}`\n        }\n        return `${url.protocol}//${url.hostname}:${url.port}`\n      }).join(',')\n    }\n    // eslint-disable-next-line camelcase\n    const peers = snapshot_provider\n    const providers = peers\n      ? `# Comma separated list of nodes to keep persistent connections to \\npersistent_peers = \"${peers}\" `\n      : 'OMG！ There is NO available providers, but you can try it.'\n    return {\n      version: '',\n      snapshot_provider,\n      servers,\n      providers,\n      height: 0,\n      hash: '',\n      error: [],\n      state: '',\n      valid: false,\n      snapshot: `[state-sync]\n# snapshot-interval specifies the block interval at which local state sync snapshots are\n# taken (0 to disable). Must be a multiple of pruning-keep-every.\nsnapshot-interval = 1000\n\n# snapshot-keep-recent specifies the number of recent snapshots to keep and serve (0 to keep all). Each snapshot is about 500MiB\nsnapshot-keep-recent = 2`,\n    }\n  },\n  created() {\n    const interval = 1000\n    this.$http.getLatestBlock().then(l => {\n      const { height } = l.block.header\n      if (height > interval * 3) {\n        this.$http.getBlockByHeight(Math.trunc((height - 3 * interval) / interval) * interval).then(x => {\n          this.hash = x.block_id.hash\n          this.height = x.block.header.height\n          this.state = `[statesync]\nenable = true\nrpc_servers = \"${this.servers}\"\ntrust_height = ${this.height}\ntrust_hash = \"${this.hash}\"\ntrust_period = \"168h\"  # 2/3 of unbonding time`\n          this.check()\n        })\n      }\n      this.$http.getNodeInfo().then(res => {\n        this.version = res.application_version.version\n      })\n    })\n  },\n  methods: {\n    check() {\n      this.valid = true\n      this.error = []\n      this.state.split('\\n').forEach(element => {\n        const v = this.kv(element)\n        if (v[0] === 'trust_height' && Number(v[1]) < 1) {\n          this.valid = false\n          this.error.push('Trust Height should be set.')\n        }\n        if (v[0] === 'trust_hash' && v[1].length < 10) {\n          this.valid = false\n          this.error.push('Trust Hash is invalid.')\n        }\n        if (v[0] === 'rpc_servers') {\n          if (v[1].indexOf(',') > 1) {\n            v[1].replace(/\"/g, '').split(',').forEach(host => {\n              const re = /^(.)+:\\d+$/g\n              if (!re.test(host)) {\n                this.valid = false\n                this.error.push(`\"${host}\" is not a valid host. Make sure that the port is added.`)\n              }\n            })\n            // valid = true\n          } else {\n            this.valid = false\n            this.error.push('No RPC serser is configured.')\n          }\n        }\n      })\n      return this.valid\n    },\n    kv(line) {\n      if (line && line.indexOf('=') > 0) {\n        const s = line.split('=')\n        return [s[0].trim(), s[1].trim()]\n      }\n      return []\n    },\n  },\n}\n</script>\n"]},"metadata":{},"sourceType":"module"}